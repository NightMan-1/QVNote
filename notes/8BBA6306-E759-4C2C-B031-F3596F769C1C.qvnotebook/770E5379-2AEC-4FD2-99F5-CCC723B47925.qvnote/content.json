{"title":"Now You See Me: How To Defer, Lazy-Load And Act With IntersectionObserver","cells":[{"type":"","data":"<p>Once upon a time, there lived a web developer who successfully convinced his customers that <a href=\"http://dowebsitesneedtolookexactlythesameineverybrowser.com\" target=\"_blank\">sites should not look the same in all browsers</a>, cared about accessibility, and was an early adopter of <a href=\"https://gridbyexample.com\" target=\"_blank\">CSS grids</a>. But deep down in his heart it was performance that was his true passion: He constantly <a href=\"https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/\" target=\"_blank\">optimized, minified, monitored, and even employed psychological tricks</a> in his projects.</p><p>Then, one day, he learned about lazy-loading images and other assets that are not immediately visible to users and are not essential for rendering meaningful content on the screen. It was the beginning of the dawn: The developer entered the evil world of <a href=\"http://www.jquerybyexample.net/2014/02/awesome-jquery-lazy-load-plugins.html\" target=\"_blank\">lazy-loading jQuery plugins</a> (or maybe the not-so-evil world of <code>async</code> and <code>defer</code> attributes). Some even say that he got straight into the core of all the evils: the world of <code><a href=\"https://css-tricks.com/snippets/javascript/lazy-loading-images/\" target=\"_blank\">scroll</a></code><a href=\"https://css-tricks.com/snippets/javascript/lazy-loading-images/\" target=\"_blank\"> event listeners</a>. We’ll never know for sure where he ended up, but then again this developer is absolutely fictitious, and any similarity to any developer is merely coincidental.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/61a1ec8c-ba21-4e89-9863-a50818961950/intersectionobserver-developer-opt.jpg\" alt=\"a web developer\">The fictitious web developer</p><p>Well, you can now say that Pandora’s box has been opened and that our fictitious developer doesn’t make the issue any less real. Nowadays, <a href=\"https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent\" target=\"_blank\">prioritizing the above-the-fold content</a> became utterly important for the performance of our web projects from both speed and page weight points of view.</p><p>In this article, we are going to go out of the <code>scroll</code> darkness and talk about the modern way of lazy-loading resources. Not just lazy-loading images, but loading any asset for that matter. More so, the technique we are going to talk about today is capable of much more than just lazy-loading assets: We will be able to provide any type of deferred functionality based on the elements’ visibility to users.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fba25daa-8a96-4af0-84d1-b8141825ce35/intersectionobserver-now-you-see-me-opt.jpg\" alt=\"IntersectionObserver: Now You See Me\"></p><p>Ladies and gentlemen, let’s talk about the Intersection Observer API. But before we begin, let’s take a look at the modern tools’ landscape that led us to <code>IntersectionObserver</code>.</p><p>2017 was a very good year for tools built into our browsers, helping us to improve the quality as well as the style of our code-base without too much effort. These days, the web seems to be moving away from sporadic solutions based on <em>very different</em> to solving <em>very typical</em> to a more well-defined approach of Observer interfaces (or just “Observers”): Well-supported <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\" target=\"_blank\">MutationObserver</a> got new family members that were quickly adopted in modern browsers:</p><ul><li><a href=\"https://www.w3.org/TR/intersection-observer/#intersection-observer-api\" target=\"_blank\">IntersectionObserver</a> and</li><li><a href=\"https://www.w3.org/TR/performance-timeline-2/#the-performanceobserver-interface\" target=\"_blank\">PerformanceObserver</a> (as part of <a href=\"https://www.w3.org/TR/performance-timeline-2\" target=\"_blank\">Performance Timeline Level 2</a> specification).</li></ul><p>One more potential family member, <a href=\"http://docs.w3cub.com/dom/fetchobserver/\" target=\"_blank\">FetchObserver</a>, is a work in progress and guides us more into the lands of a network proxy, but today I would like to talk more about front-end instead.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7de0335c-246e-4665-8b44-0438e16cd653/intersectionobserver-observers-family-opt.jpg\" alt=\"IntersectionObserver and PerformanceObserver are the new members of the Observers family.\">IntersectionObserver and PerformanceObserver are the new members of the Observers family.</p><p><code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\" target=\"_blank\">PerformanceObserver</a></code> and <code><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\" target=\"_blank\">IntersectionObserver</a></code> aim at helping front-end developers improve the performance of their projects at different points. The former gives us the tool for the Real User Monitoring, while the latter is the tool, providing us with tangible performance improvement. As mentioned before, this article will take a detailed look exactly at the latter one: <strong>IntersectionObserver</strong>. In order to understand the mechanics of <code>IntersectionObserver</code> in particular, we should take a look at how a generic Observer is supposed to work in the modern web.</p><p><strong>Pro Tip</strong>: You can skip the theory and dive into the <a href=\"https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/#deconstructing-intersectionobserver\" target=\"_blank\">mechanics of IntersectionObserver</a> right away or, even further, straight to the <a href=\"https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/#possible-applications\" target=\"_blank\">possible applications</a> of <code>IntersectionObserver</code>.</p><h3>Observer vs. Event</h3><p>An “Observer,” as the name implies, is intended to observe something that happens in the context of a page. Observers can watch something happening on a page, like DOM changes. They can also watch for page’s lifecycle events. Observers can also run some callback functions. Now attentive reader might immediately spot the issue here and ask, “So, what is the point? Don’t we have events for this purpose already? What makes Observers different?” Very good point! Let’s take a closer look and sort it out.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c0b2f86d-330f-4e26-b4fa-b7aebde6f080/intersectionobserver-observer-vs-event-opt.jpg\" alt=\"Observer vs. Event: what's the difference?\">Observer vs. Event: What's the difference?</p><p>The crucial difference between regular Event and Observer is that by default, the former reacts synchronously for every occurrence of the Event, affecting the main thread’s responsiveness, while the latter should react asynchronously without affecting performance that much. At least, this is true for the currently presented Observers: <strong>All of them behave asynchronously</strong>, and I don’t think this will change in the future.</p><p>This leads to the main difference in handling the callbacks of Observers that might confuse the beginners: Observers’ async nature might result in several observables being passed to a callback function at the same time. Because of this, the callback function should expect not a single entry but an <code>Array</code> of entries (even though sometimes the Array will contain only one entry in it).</p><p>Moreover, some Observers (in particular the one we are talking about today) provide a very handy pre-computed properties, which otherwise, we used to calculate ourselves using expensive (from performance standpoint) methods and properties when using regular events. To clarify this point, we will get to an example a bit later in the article.</p><p>So if it’s hard for somebody to step aside from the Event paradigm, I would say that Observers are events on steroids. Another description would be: Observers are a new level of approximation on top of the events. But no matter which definition you prefer, it should come without saying that Observers are not intended to replace events (at least not yet); there are enough use cases for both, and they can happily live side-by-side.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0c51b9a1-7e49-4058-9b96-45dd0d0d6dc1/intersectionobserver-obser-event-bff-opt.jpg\" alt=\"Observers are not intended to replace Events: Both can live together happily.\">Observers are not intended to replace Events: Both can live together happily.</p><h3>Generic Observer’s Structure</h3><p>The generic structure of an Observer (any of those available at the time of writing) looks similar to this:</p><pre>/**\n* Typical Observer's registration\n*/\nlet observer = new YOUR-TYPE-OF-OBSERVER(function (entries) {\n  // entries: Array of observed elements\n  entries.forEach(entry =&gt; {\n      // Here we can do something with each particular entry\n  });\n});\n\n// Now we should tell our Observer what to observe\nobserver.observe(WHAT-TO-OBSERVE);\n</pre><p>Copy</p><ul><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICA7IEZ3JCWBITKJJCASDK2QKC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\"><img src=\"https://smashing-delivery.herokuapp.com/catch?uri=https://cdn4.buysellads.net/uu/1/41334/1546414089-hotjar-logo.png\"></a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICA7IEZ3JCWBITKJJCASDK2QKC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">Hotjar</a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICA7IEZ3JCWBITKJJCASDK2QKC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">See how your visitors are really using your website.</a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICA7IEZ3JCWBITKJJCASDK2QKC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">Try it for Free </a></li></ul><p>Again, note that <code>entries</code> is an <code>Array</code> of values, not a single entry.</p><p>This is the generic structure: Implementations of particular Observers differ in the arguments being passed into it’s <code>observe()</code> and the arguments passed into its callback. For example <code>MutationObserver</code> should also get a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit\" target=\"_blank\">configuration object</a> to know more about what changes in the DOM to observe. <code>PerformanceObserver</code> doesn’t observe nodes in DOM, but instead <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/observe\" target=\"_blank\">has the dedicated set of entry types</a> it can observe.</p><p>Here, let’s finish the “generic” part of this discussion and dive deeper into the topic of today’s article — <code>IntersectionObserver</code>.</p><h3>Deconstructing IntersectionObserver</h3><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ead4cc6b-7bed-40aa-9da3-0c17760291f8/intersectionobserver-intersectionobserver-opt.jpg\" alt=\"Deconstructing IntersectionObserver\">Deconstructing IntersectionObserver</p><p>First of all, let’s sort out what <code>IntersectionObserver</code> is.</p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\" target=\"_blank\">According to MDN</a>:</p><blockquote>The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.</blockquote><p>Simply put, <code>IntersectionObserver</code> asynchronously observes overlapping of one element by another element. Let’s talk about what those elements are for in <code>IntersectionObserver</code>.</p><h4>IntersectionObserver Initialization</h4><p>In one of the previous paragraphs, we have seen the structure of a generic Observer. <code>IntersectionObserver</code> extends this structure a bit. First of all, this type of Observer requires a configuration with three main elements:</p><ul><li><code><strong>root</strong></code>: This is the root element used for the observation. It defines the basic “capturing frame” for observable elements. By default, the <code>root</code> is the <strong>viewport</strong> of your browser but can really be any element in your DOM (then you set <code>root</code> to something like <code>document.getElementById('your-element')</code>). Keep in mind though that the elements you want to observe must “live” in <code>root</code>’s DOM tree in this case.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7f063b78-a149-44e8-af19-750d2ce489dd/intersectionobserver-props-root-opt.jpg\" alt=\"root's property of IntersectionObserver's config\"><code>root</code> property defines the base for 'capturing frame' for our elements.</p><ul><li><code><strong>rootMargin</strong></code>: Defines margin around your <code>root</code> element that <em>extends</em> or <em>shrinks</em> the “capturing frame” when your <code>root</code>’s dimensions do not provide enough flexibility. The options for this configuration’s values are similar to those of <code>margin</code> in CSS, such as <code>rootMargin: '50px 20px 10px 40px'</code> (top, right bottom, left). The values can be shorthanded (like <code>rootMargin: '50px'</code>) and can be expressed in either <code>px</code> or <code>%</code>. By default, <code>rootMargin: '0px'</code>.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/08ecf6a6-d230-4c7c-946c-59720be4e315/intersectionobserver-props-rootmargin-opt.jpg\" alt=\"rootMargin property of IntersectionObserver's config\"><code>rootMargin</code> property expands/contracts the 'capturing frame' which is defined by <code>root</code>.</p><ul><li><code><strong>threshold</strong></code>: It’s not always wanted to react instantly when an observed element intersects a border of the “capturing frame” (defined as a combination of <code>root</code> and <code>rootMargin</code>). <code>threshold</code> defines the percentage of such intersection at which Observer should react. It can be defined as a single value or as an array of values. To better understand <code>threshold</code>’s effect (I know it might be confusing sometimes), here are some examples:</li><li class=\"ql-indent-1\"><code>threshold: 0</code>: <strong>The default value</strong> <code>IntersectionObserver</code> should react when the very first or very last pixel of an observed element intersects one of the borders of the “capturing frame.” Keep in mind that <code>IntersectionObserver</code> is direction-agnostic, meaning that it will react in both scenarios: a) when the element <em>enters</em> and b) when it <em>leaves</em> the “capturing frame.”</li><li class=\"ql-indent-1\"><code>threshold: 0.5</code>: Observer should be fired when 50% of an observed element intersects the “capturing frame”;</li><li><code>threshold: [0, 0.2, 0.5, 1]</code>: Observer should react in 4 cases:</li><li class=\"ql-indent-2\">The very first pixel of an observed element enters the “capturing frame”: the element is <em>still not</em> really within that frame, or the very last pixel of the observed element leaves the “capturing frame”: the element is <em>no longer</em> within the frame;</li><li class=\"ql-indent-2\">20% of the element is within the “capturing frame” (again, direction doesn’t matter for <code>IntersectionObserver</code>);</li><li class=\"ql-indent-2\">50% of the element is within the “capturing frame”;</li><li class=\"ql-indent-1\">100% of the element is within the “capturing frame.” This is strictly opposite to <code>threshold: 0</code>.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb5097c3-01db-40d4-b3ef-f5032d00e5ca/intersectionobserver-props-threshold-copy-opt.jpg\" alt=\"threshold property of IntersectionObserver's config\"><code>threshold</code> property defines by how much the element should intersect our 'capturing frame' before the Observer gets fired.</p><p>In order to inform our <code>IntersectionObserver</code> of our desired configuration, we simply pass our <code>config</code> object into our Observer’s constructor along with our callback function like this:</p><pre>const config = {\n  root: null, // avoiding 'root' or setting it to 'null' sets it to default value: viewport\n  rootMargin: '0px',\n  threshold: 0.5\n};\nlet observer = new IntersectionObserver(function(entries) {\n    …\n}, config);\n</pre><p>Copy</p><p>Now, we should give <code>IntersectionObserver</code> the actual element to observe. This is done simply by passing the element to <code>observe()</code> function:</p><pre>…\nconst img = document.getElementById('image-to-observe');\nobserver.observe(image);\n</pre><p>Copy</p><p>A couple of things to note about this observed element:</p><ul><li>It has been mentioned previously, but is worth being mentioned again: In case you set <code>root</code> as an element in the DOM, the observed element should be located within the DOM tree of <code>root</code>.</li><li><code>IntersectionObserver</code> can accept only one element for observation at a time and doesn’t support batch supply for observations. This means if you need to observe several elements (let’s say several images on a page), you have to iterate over all of them and observe each of them separately:</li></ul><pre>…\nconst images = document.querySelectorAll('img');\nimages.forEach(image =&gt; {\n    observer.observe(image);\n});\n</pre><p>Copy</p><ul><li>When loading a page with Observer in place, you might notice that the <code>IntersectionObserver</code>’s callback has been fired for all observed elements at once. Even those that do not match the supplied configuration. “Well… not really what I expected,” is the usual thought when experiencing this for the first time. But don’t get confused here: this doesn’t necessarily mean that those observed elements somehow intersect the “capturing frame” while the page is loading.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/28a48e0b-6106-443a-a3d8-9e3bad6d9c1a/intersectionobserver-devtools-scr-opt.jpg\" alt=\"Screenshot of DevTools with IntersectionObserver being fired for all elements at once.\"><code>IntersectionObserver</code> will be fired for all observed elements once they are registered, but it doesn't mean that they all intersect our 'capturing frame'.</p><ul><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICYBILZ3JCWBITKJJCAAIPK7KC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\"><img src=\"https://smashing-delivery.herokuapp.com/catch?uri=https://cdn4.buysellads.net/uu/1/41312/1549580989-Atlassian-horizontal-white_2x-rgb.png\"></a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICYBILZ3JCWBITKJJCAAIPK7KC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">Atlassian</a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICYBILZ3JCWBITKJJCAAIPK7KC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">Quick. Proactive. Iterative. Atlassian’s collaboration software transforms how IT teams work together to deliver more.</a></li><li><a href=\"https://smashing-delivery.herokuapp.com/ball?uri=//srv.buysellads.com/ads/click/x/GTND42QMCTYIT2JUCE74YKQMCWYD453ICYBILZ3JCWBITKJJCAAIPK7KC6BIPK3JCTSDTK3EHJNCLSIZ\" target=\"_blank\">See what IT can be </a></li></ul><p>What it means though, is that the entry for this element became initialized and is now controlled by your <code>IntersectionObserver</code>. This might add unnecessary noise to your callback function though, and it becomes your responsibility to detect which elements do indeed intersect the “capturing frame” and which we still don’t need to account for. To understand how to do that detection, let’s get a bit deeper into the anatomy of our callback function and take a look at what such entries consist of.</p><h4>IntersectionObserver Callback</h4><p>First of all, the callback function for an <code>IntersectionObserver</code> takes two arguments, and we will talk about these in reversed order starting with the <em>second</em> argument. Along with the aforementioned <code>Array</code> of observed entries, intersecting our “capturing frame,” the callback function gets the <strong>Observer itself</strong> as the <em>second</em> argument.</p><h4>Reference To Observer Itself</h4><pre>new IntersectionObserver(function(entries, SELF) {…});\n</pre><p>Copy</p><p>Getting the reference to the Observer itself is useful in a lot of scenarios when you want to stop observing some element after it has been detected by the <code>IntersectionObserver</code> for the first time. Scenarios like lazy loading of the images, deferred fetch of other assets, etc. are of this kind. When you want to stop observing an element, <code>IntersectionObserver</code> provides a <code><a href=\"https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-unobserve\" target=\"_blank\">unobserve(element-to-stop-observing)</a></code><a href=\"https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-unobserve\" target=\"_blank\"> method</a> that can be run in the callback function after performing some actions on the observed element (like actual lazy loading of an image, for example).</p><p>Some of these scenarios will be reviewed further in the article, but with this second argument out of our way, let’s get to the main actors of this callback play.</p><h4>IntersectionObserverEntry</h4><pre>new IntersectionObserver(function(ENTRIES, self) {…});\n</pre><p>Copy</p><p>The <code>entries</code> we are getting in our callback function as an <code>Array</code> are of the special type: <code><a href=\"https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\" target=\"_blank\">IntersectionObserverEntry</a></code>. This interface provides us with <a href=\"https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\" target=\"_blank\">a pre-defined and pre-calculated set of properties</a> concerning each particular observed element. Let’s take a look at the most interesting ones.</p><p>First of all, entries of <code>IntersectionObserverEntry</code> type come with information about three different rectangles — defining coordinates and boundaries of the elements involved in the process:</p><ul><li><code><strong>rootBounds</strong></code>: A rectangle for the “capturing frame” (<code>root</code> + <code>rootMargin</code>);</li><li><code><strong>boundingClientRect</strong></code>: A rectangle for the observed element itself;</li><li><code><strong>intersectionRect</strong></code>: An area of the “capturing frame” intersected by the observed element.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0c9b56a3-5870-42ec-a3b5-0fc85f85aba7/intersectionobserver-entry-rectangles-opt.jpg\" alt=\"Rectangles of IntersectionObserverEntry\">All the bounding rectangles involved in IntersectionObserverEntry are calculated for you.</p><p>The really cool thing about these rectangles being calculated for us asynchronously is that it gives us important information related to element’s positioning without us calling <code>getBoundingClientRect()</code>, <code>offsetTop</code>, <code>offsetLeft</code> and other <a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\" target=\"_blank\">expensive positioning properties and methods</a> triggering <a href=\"http://kellegous.com/j/2013/01/26/layout-performance/\" target=\"_blank\">layout thrashing</a>. Pure win for performance!</p><p>Another property of <code>IntersectionObserverEntry</code> interface that is interesting for us is <code><strong>isIntersecting</strong></code>. This is a convenience property indicating whether the observed element is currently intersecting the “capturing frame” or not. We could, of course, get this information by looking at the <code>intersectionRect</code> (if this rectangle is not 0×0, the element is intersecting the “capturing frame”) but having this pre-calculated for us is quite convenient.</p><p><code>isIntersecting</code> can be used to find out whether the observed element is just entering the “capturing frame” or is already leaving it. To find this out, save the value of this property as a global flag and when the new entry for this element arrives to your callback function, compare it’s new <code>isIntersecting</code> with that global flag:</p><ul><li>If it was <code>false</code> and now it’s <code>true</code>, then the element is entering the “capturing frame”;</li><li>If it’s the opposite and it’s <code>false</code> now while it was <code>true</code> before, then the element is leaving the “capturing frame.”</li></ul><p><code>isIntersecting</code> is exactly the property that helps us solve the problem we discussed earlier, i.e., separate entries for the elements that really intersect the “capturing frame” from the noise of those being just the entry’s initialization.</p><pre>let isLeaving = false;\nlet observer = new IntersectionObserver(function(entries) {\n  entries.forEach(entry =&gt; {\n    if (entry.isIntersecting) {\n      // we are ENTERING the \"capturing frame\". Set the flag.\n      isLeaving = true;\n          // Do something with entering entry\n    } else if (isLeaving) {\n      // we are EXITING the \"capturing frame\"\n      isLeaving = false;\n      // Do something with exiting entry\n    }\n  });\n}, config);\n</pre><p>Copy</p><p><strong>NOTE</strong>: In Microsoft Edge 15, <code>isIntersecting</code> property was not implemented, returning <code>undefined</code> despite full support for <code>IntersectionObserver</code> otherwise. <a href=\"https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12156111/\" target=\"_blank\">This has been fixed</a> in July 2017 though and is available since Edge 16.</p><p><code>IntersectionObserverEntry</code> interface provides one more pre-calculated convenience property: <code><strong>intersectionRatio</strong></code>. This parameter can be used for the same purposes as <code>isIntersecting</code> but provides more granular control due to it being a floating point number instead of boolean value. The value of <code>intersectionRatio</code> indicates how much of the observed element’s area is intersecting the “capturing frame” (the ratio of <code>intersectionRect</code> area to <code>boundingClientRect</code> area). Again, we could make this calculation ourselves using information from those rectangles, but it’s good to have it done for us.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2e750778-9a85-4ab5-8e56-9d8f672eb04d/intersectionobserver-intersectionratio-opt.jpg\" alt=\"Doesn't it look familiar already? Yes, <code>intersectionRatio</code> property is similar to <code>threshold</code> property of Observer's config. The difference is that the latter defines <em>when</em> to fire up Observer, the former indicates real intersection's situation (that is slightly different from <code>threshold</code> due to asynchronous nature of Observer).\">Doesn't it look familiar already? Yes, <code>intersectionRatio</code> property is similar to <code>threshold</code> property of Observer's config. The difference is that the latter defines *when* to fire up Observer, the former indicates real intersection's situation (that is slightly different from <code>threshold</code> due to asynchronous nature of Observer).</p><p><code><strong>target</strong></code> is one more property of the <code>IntersectionObserverEntry</code> interface that you might need to get to quite often. But there is absolutely no magic here – it’s just the original element that had been passed to <code>observe()</code> function of your Observer. Just like <code>event.target</code> you’ve got used to when working with events.</p><p>To get the full list of properties for the <code>IntersectionObserverEntry</code> interface do <a href=\"https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\" target=\"_blank\">check the specification</a>.</p><h3>Possible Applications</h3><p>I realize that you most probably came to this article exactly because of this chapter: who cares about mechanics when we have code snippets for copy and paste after all? So won’t bother you with more discussion now: we’re getting into the land of code and examples. I hope that the comments included within the code will make things more clear.</p><h4>Deferred Functionality</h4><p>First of all, let’s review an example revealing the basic principles underlying the idea of <code>IntersectionObserver</code>. Let’s say you have an element that has to do a lot of computations once it’s on the screen. For example, your ad should register a view only when it has actually been shown to a user. But now, let’s imagine that you have an auto-played carousel element somewhere below the first screen on your page.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e6047e11-da43-4773-a01f-0c8f133ce726/intersectionobserver-carousel-second-screen-opt.jpg\" alt=\"Carousel below the first screen of your application\">When we have a carousel or any other heavy-lifting functionality below the fold of our application, it's a waste of resources to start bootstrapping/loading it right away.</p><p>Running a carousel, in general, is a heavy task. Usually, it involves JavaScript timers, calculations to automatically scroll through the elements, etc. All of these tasks load the main thread, and when it’s done in auto-play mode, it’s hard for us to know when our main thread gets this hit. When we are talking about prioritizing content on our first screen and want to hit <a href=\"https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint\" target=\"_blank\">First Meaningful Paint</a> and <a href=\"https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive\" target=\"_blank\">Time To Interactive</a> as soon as possible, blocked main thread becomes a bottleneck for our performance.</p><p>To fix the issue, we might defer playback of such a carousel until it gets into the browser’s viewport. For this case, we will employ our knowledge and example for the <code>isIntersecting</code> parameter of the <code>IntersectionObserverEntry</code> interface.</p><pre>const carousel = document.getElementById('carousel');\nlet isLeaving = false;\nlet observer = new IntersectionObserver(function(entries) {\n  entries.forEach(entry =&gt; {\n        if (entry.isIntersecting) {\n          isLeaving = true;\n          entry.target.startCarousel();\n        } else if (isLeaving) {\n          isLeaving = false;\n          entry.target.stopCarousel();\n        }\n    });\n}\nobserver.observe(carousel);\n</pre><p>Copy</p><p>Here, we play the carousel only when it gets into our viewport. Notice the absence of <code>config</code> object passed to <code>IntersectionObserver</code>’s initialization: this means we rely on default configuration options. When the carousel gets out of our viewport, we should stop playing it to not spend resources on the not-important-anymore elements.</p><h4>Lazy Loading Of Assets</h4><p>This is, probably, the most obvious use-case for <code>IntersectionObserver</code>: we do not want to spend resources to download something that user doesn’t need right now. This will give a huge benefit to your users: users won’t need to download, and their mobile devices won’t need to parse and compile a lot of useless information that they do not need at the moment. Unsurprisingly at all, it will also help the performance of your app.</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d01eaff-5c1d-40fd-ba02-16a4fc32aec5/intersectionobserver-gallery-second-screen-opt.jpg\" alt=\"Lazy-loading images below the fold\">Lazy-loading assets like images located below the first screen – the most obvious application of IntersectionObserver.</p><p>Previously, in order to defer downloading and processing resources until the moment user might get them on screen, we were dealing with event listeners on events like <code>scroll</code>. The problem is obvious: this triggered the listeners way too often. So we had to come up with the idea of throttling or debouncing the callback’s execution. But all of this added a lot of pressure on our main thread blocking it when we most needed it.</p><p>So, getting back to <code>IntersectionObserver</code> in a lazy-loading scenario, what should we keep an eye on? Let’s check <a href=\"https://codepen.io/mishunov/full/qpmWYP\" target=\"_blank\">a simple example of lazy-loading images</a>.</p><p>Try slowly scrolling that page to the “third screen” and watch the monitoring window in the top right corner: it will let you know how many images have been downloaded so far.</p><p>In the core of HTML markup for this task lays a simple sequence of images:</p><pre>…\n&lt;img data-src=\"https://blah-blah.com/foo.jpg\"&gt;\n…\n</pre><p>Copy</p><p>As you can see, the images should come without <code>src</code> tags: once a browser sees <code>src</code> attribute, it will start downloading that image right away that is opposite to our intentions. Hence we should not put that attribute on our images in HTML, and instead, we might rely on some <code>data-</code> attribute like <code>data-src</code> here.</p><p>Another part of this solution is, of course, JavaScript. Let’s focus on the main bits here:</p><pre>const images = document.querySelectorAll('[data-src]');\nconst config = { … };\n\nlet observer = new IntersectionObserver(function (entries, self) {\n  entries.forEach(entry =&gt; {\n      if (entry.isIntersecting) { … }\n  });\n}, config);\nimages.forEach(image =&gt; { observer.observe(image); });\n</pre><p>Copy</p><p>Structure-wise, there is nothing new here: we have covered all of this before:</p><ul><li>We get all messages with our <code>data-src</code> attributes;</li><li>Set <code>config</code>: for this scenario you want to expand your “capturing frame” to detect elements a bit lower than the bottom of the viewport;</li><li>Register <code>IntersectionObserver</code> with that config;</li><li>Iterate over our images and add all of them to be observed by this <code>IntersectionObserver</code>;</li></ul><p>The interesting part happens within the callback function invoked on the entries. There three essential steps involved.</p><ol><li>First of all, we process only the items that are really intersecting our “capturing frame.” This snippet should be familiar to you by now.</li></ol><pre>entries.forEach(entry =&gt; {\nif (entry.isIntersecting) { … }\n});\n</pre><ol><li>Copy</li><li>Then, we somehow process the entry by converting our image with <code>data-src</code> into a real <code>&lt;img src=\"…\"&gt;</code>.</li></ol><pre>if (entry.isIntersecting) {\npreloadImage(entry.target);\n…\n}\n</pre><ol><li>Copy</li><li>This will trigger the browser to finally download the image. <code>preloadImage()</code> is a very simple function not worth being mentioned here. Just read the source.</li><li>Next and final step: since lazy loading is a one-time action and we do not need to download the image every time the element gets into our “capturing frame,” we should <code>unobserve</code> the already-processed image. The same way as we should do it with <code>element.removeEventListener()</code> for our regular events when those are not needed anymore to prevent memory leaks in our code.</li></ol><pre>if (entry.isIntersecting) {\npreloadImage(entry.target);\n// Observer has been passed as self to our callback\nself.unobserve(entry.target);\n}\n</pre><ol><li>Copy</li></ol><p><strong>Note.</strong> Instead of <code>unobserve(event.target)</code> we could also call <code>disconnect()</code>: it completely disconnects our <code>IntersectionObserver</code> and would not observe images anymore. This is useful if the only thing you care about is the first ever hit for your Observer. In our case, we need the Observer to keep monitoring the images, so we shouldn’t disconnect just yet.</p><p>Feel free to fork <a href=\"https://codepen.io/mishunov/pen/qpmWYP\" target=\"_blank\">the example</a> and play with different settings and options. There is one <strong>interesting thing to mention</strong> though when you want to lazy load the images in particular. You should always keep the box, generated by the observed element in mind! If you check the example, you will notice that the CSS for images on lines 41–47 contains supposedly redundant styles, incl. <code>min-height: 100px</code>. This is done to give the image placeholders (<code>&lt;img&gt;</code> without <code>src</code> attribute) some vertical dimension. What for?</p><ul><li>Without vertical dimensions, all <code>&lt;img&gt;</code> tags would generate 0×0 box;</li><li>Since <code>&lt;img&gt;</code> tag generates some sort of <code>inline-block</code> box by default, all of those 0×0 boxes would be aligned side-by-side on the same line;</li><li>This means that your <code>IntersectionObserver</code> would register all (or, depending on how fast you scroll, <em>almost</em> all of) the images at once — probably not quite what you want to achieve.</li></ul><h4>Current Section’s Highlighting</h4><p><code>IntersectionObserver</code> is much more than just lazy loading, of course. Here is <a href=\"https://codepen.io/mishunov/full/opeRdL\" target=\"_blank\">another example</a> of replacing <code>scroll</code> event with this technology. In this one we have a pretty common scenario: on the fixed navigation bar we should highlight current section based on the scrolling position of the document.</p><p>Structurally, it’s similar to the example for lazy-loading images and has the same base structure with the following exceptions:</p><ul><li>Now we want to observe not images, but the sections on the page;</li><li>Obviously enough, we also have a different function to process the entries in our callback (<code>intersectionHandler(entry)</code>). But this one is not interesting: all it does is toggling the CSS class.</li></ul><p>What is interesting here is the <code>config</code> object though:</p><pre>const config = { rootMargin: '-50px 0px -55% 0px' };\n</pre><p>Copy</p><p>Why not the default value of <code>0px</code> for <code>rootMargin</code>, you ask? Well, simply because highlighting the current section and lazy loading an image are quite different in what we try to achieve. With lazy loading, we want to start loading before the image gets into the view. Hence for that purpose, we extended our “capturing frame” by 50px at the bottom. On the contrary, when we want to highlight the current section, we have to be sure that the section is actually visible on the screen. And not only that: we have to be sure that user is, actually, reading or going to read exactly this section. Hence, we want a section to go a bit more than half the viewport from the bottom before we could declare it the active section. Also, we want to account for the height of the navigation bar, and so we remove the bar’s height from the “capturing frame.”</p><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/daee96d7-7a40-48b4-8b46-e459f59ec2c0/capturing-frame-sections2-opt.jpg\" alt=\"Capturing frame for current section\">We want the Observer to only detect elements that get into the 'capturing frame' between 50px from the top and 55% of the viewport from the bottom.</p><p>Also, <strong>note</strong> that in case of highlighting the current navigation item, we do not want to stop observing anything. Here we should always keep <code>IntersectionObserver</code> in charge, hence you will find neither <code>disconnect()</code> nor <code>unobserve()</code> here.</p><h3>Summary</h3><p><code>IntersectionObserver</code> is a very straight-forward technology. It has a <a href=\"https://caniuse.com/#search=IntersectionObserver\" target=\"_blank\">pretty good support in the modern browsers</a> and if you want to implement it for browsers that still (or won’t at all) support it, of course, <a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\" target=\"_blank\">there is a polyfill for that</a>. But all in all, this is a great technology that allows us to do all sorts of things related to detecting elements in a viewport while helping to achieve a really good performance boost.</p><h4>Why Is IntersectionObserver Good For You?</h4><ul><li><code>IntersectionObserver</code> is an async non-blocking API!</li><li><code>IntersectionObserver</code> replaces our expensive listeners on <code>scroll</code> or <code>resize</code> events.</li><li><code>IntersectionObserver</code> does all the expensive calculations like <code>getClientBoundingRect()</code> for you so that you don’t need to.</li><li><code>IntersectionObserver</code> follows the structural pattern of other Observers out there so, theoretically, should be easy to understand if you’re familiar with how other Observers work.</li></ul><h4>Things To Keep In Mind</h4><p>If we compare IntersectionObserver’s capabilities to the world of <code>window.addEventListener('scroll')</code> from where it all came, it will be hard to see any cons in this Observer. So, let’s just note some things to keep in mind instead:</p><ul><li>Yes, <code>IntersectionObserver</code> is an async non-blocking API. This is great to know! But it is even more important to understand that the code you’re running in your callbacks will not be run asynchronously by default even though the API itself is async. So there is still a chance to eliminate all the benefits you get from <code>IntersectionObserver</code> if your callback function’s calculations make the main thread unresponsive. But this is a different story.</li><li>If you’re using <code>IntersectionObserver</code> for lazy loading the assets (like images, for example), run <code>.unobserve(asset)</code> after the asset has been loaded.</li><li><code>IntersectionObserver</code> can detect intersections only for the elements that appear in the <a href=\"https://www.w3.org/TR/CSS2/intro.html#formatting-structure\" target=\"_blank\">formatting structure</a> of the document. To make it clear: the observable elements should generate a box and somehow affect the layout. Here are just some examples to give you a better understanding:</li><li class=\"ql-indent-1\">Elements with <code>display: none</code> are out of the question;</li><li class=\"ql-indent-1\"><code>opacity: 0</code> or <code>visibility:hidden</code> do create the box (even though invisible) so these will be detected;</li><li class=\"ql-indent-1\">Absolutely positioned elements with <code>width:0px; height:0px</code> are fine. Though, it has to be noted that absolutely positioned elements fully positioned <em>outside</em> of parent’s borders (with negative margins or negative <code>top</code>, <code>left</code>, etc.) and are cut out by parent’s <code>overflow: hidden</code> won’t be detected: their box is out of scope for the formatting structure.</li></ul><p><img src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/df80373c-cec8-4ca3-a766-4861f8adc359/intersectionobserver-final-opt.jpg\" alt=\"IntersectionObserver: Now You See Me\">IntersectionObserver: Now You See Me</p><p>I know it was a long article, but if you’re still around, here are some links for you to get an even better understanding and different perspectives on the Intersection Observer API:</p><ul><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\" target=\"_blank\">Intersection Observer API on MDN</a>;</li><li><a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\" target=\"_blank\">IntersectionObserver polyfill</a>;</li><li><a href=\"https://www.npmjs.com/package/intersection-observer\" target=\"_blank\">IntersectionObserver polyfill as </a><code><a href=\"https://www.npmjs.com/package/intersection-observer\" target=\"_blank\">npm</a></code><a href=\"https://www.npmjs.com/package/intersection-observer\" target=\"_blank\"> module</a>;</li><li><a href=\"https://www.youtube.com/watch?v=ncYQkOrKTaI\" target=\"_blank\">Lazy-Loading Images with IntersectionObserver [video]</a> by amazing <a href=\"https://twitter.com/aerotwist\" target=\"_blank\">Paul Lewis</a>;</li><li>Basic and short (just 01:39), but very informative <a href=\"https://www.youtube.com/watch?v=kW_atFXMG98\" target=\"_blank\">introduction to IntersectionObserver [video]</a> by <a href=\"https://twitter.com/DasSurma\" target=\"_blank\">Surma</a>.</li></ul><p>With this, I would like to make a pause in our discussion to give you an opportunity to play with this technology and realize all of its convenience. So, go play with it. The article is finally over. This time I really mean it.</p><p><br></p>"}]}
